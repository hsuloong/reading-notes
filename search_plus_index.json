{"./":{"url":"./","title":"README简介","keywords":"","body":"读书笔记 master：本分支，也是GitBook源文件分支 gh-pages：GitBook发布分支 https://hsuloong.github.io/reading-notes/ 笔记结构 按照心情或者主题独立成章。 开始吧，少年！ 多读书，读好书！ Copyright © hsuloong.github.io 2021 all right reserved，powered by Gitbook编辑于： 2021-08-11 17:29:29 "},"domain-driven-design/":{"url":"domain-driven-design/","title":"DDD领域驱动设计","keywords":"","body":"领域驱动设计 摘自英文维基百科：Domain-driven design Domain-driven design (DDD) is the concept that the structure and language of software code (class names, class methods, class variables) should match the business domain. 上面一段话翻译成中文：DDD是一个概念，其含义就是软件代码的结构和语言（类名、类方法、类变量）应该与业务领域相匹配。 关于领域驱动设计有两本值得反复阅读的书籍： 领域驱动设计：软件核心复杂性应对之道 这本书可以算是领域驱动的开山之作了，不过整本书内容比较抽象，会看的相对吃力些，需要反复阅读。 实现领域驱动设计 这本书案例比较丰富，而且作者也把Java示例代码放到网上了，适合新手阅读，我也强烈把上面那本书略读完以后精读这本书。 其他领域驱动设计的资源集合 领域驱动设计与模式实战 是《实现领域驱动设计》提到的书，这里占个坑 DDD社区 DDD社区，可以看看上面写的文章。 领域驱动设计峰会DDD-China 还没具体了解，先占个坑。 Vaughn Vernon 《实现领域驱动设计》作者官网 设计模式：可复用面向对象软件的基础 企业应用架构模式 Head First 设计模式 本书读书笔记目录说明 README.md 本文件 notes 领域驱动读书笔记，按照心情分为多个文件 practices 领域驱动学习的相关练习 Copyright © hsuloong.github.io 2021 all right reserved，powered by Gitbook编辑于： 2021-08-11 17:29:29 "},"domain-driven-design/notes/start-domain-drive-design.html":{"url":"domain-driven-design/notes/start-domain-drive-design.html","title":"开始领域驱动设计","keywords":"","body":"初识领域驱动设计 在没有了解领域驱动设计之前，大部分业务开发的工作可能就是常见的CRUD。 基本代码步骤可能就是：接受请求->请求下游RPC->处理后返回。 这基本是一个纯面向过程式的代码风格，如果有多年业务开发经验的话，应该知道这里最大的问题是代码重复率高、可维护性差，因为大量的业务逻辑散落在各个地方了。 而这种面向过程式的代码风格也很容易导致另外一个问题：面向数据库编程。 可以回忆一下，在做需求设计的时候，很多人第一个想法就是先把数据库物理模型先设计出来，然后基于这个物理模型去实现业务逻辑。 而在领域驱动设计里面，设计物理模型并不是最高优先级，领域驱动设计更加关注业务本身逻辑的设计，因此领域驱动设计里面有诸如战略建模、战术建模、限界上下文、通用语言、上下文映射图、领域、子域、聚合、实体、值对象、领域服务等概念。 一句话：如果你希望自己的工作不总是CRUD，想开发出优雅整洁可快速迭代的业务系统，那么开始学领域驱动设计肯定不会让你失望的，领域驱动设计也可以帮你从更高的高度去思考业务。 战略建模(Strategic Modeling) 战略建模主要包括设计限界上下文、通用语言、上下文映射图，用于帮助理清业务重要程度和哪些软件资产是可重新拿来使用的。 下图是《实现领域驱动设计》一书的限界上下文和通用语言一张示意图： 限界上下文是领域模型的边界，边界内的通用语言是清晰单一无歧义的。 在《实现领域驱动设计》一书中，作者曾说： 如果说Evans在软件开发社区有一项发明，那便是通用语言。可见通用语言在DDD中应当是一个需要重视的东西。 书中认为通用语言是一种协作模式，反映的是领域专家对于软件系统的思维模型，用于捕捉特定业务领域中的概念和术语。 一个特定的领域通过不同的名词、形容词和动词来表达软件模型，这些词汇（通用语言）也应当是开发团队正式使用的。 一般来说，限界上下文和通用语言是成对出现的，因为通用语言在一个限界上下文中的含义是唯一且明确的。 在一个特定的业务领域中，一般会划分出来多个限界上下文，为完成复杂的业务逻辑，他们需要集成在一起，如下示意图所示： 图中上下文之间的集成关系主要有： (1) Open Host Service：开放主机服务 (2) Published Language：发布语言 (3) Anticorruption Layer：防腐层 (4) Customer-Supplier：客户方-供应方 (5) Partnership：合作关系 (6) Conformist：遵奉者 (7) Shared Kernel：共享内核 战术建模(Tactical Modeling) 战术建模是基于某个限界上下文之中的，用于帮助创建DDD模型里面的各个部件，其有一个重要部件就是聚合。 聚合由实体、值对象组成，聚合需要在整个生命周期中保持事务一致。聚合实例通过资源库Repository进行持久化。 如下图为两个聚合： 聚合上面将会承载大部分的业务逻辑（通过调用实体或值对象的方法完成），如果有一些业务逻辑不适合出现在某个具体的实体或值对象中，则可以引入无状态的领域服务。领域服务可以操作多个聚合完成相应的业务逻辑。 而当聚合业务逻辑操作中发生重要事件时，可以通过领域事件来进行广播通知，领域事件由聚合来发布。 DDD在代码实践中引入了模块的概念，《实现领域驱动》一书中用Java的包或者C#里面的命名空间来类比。 架构(Architecture) 战略建模和战术建模应该是架构中立的，但是设计出来的领域模型之间则是存在架构。 比如：六边形(Hexagonal)架构、面向服务(Service-Oriented)架构、REST架构、事件驱动(Event-Driven)架构。 以下为《实现领域驱动》一书中关于DDD的六边形架构示意图： DDD一些概念简介 领域模型 It’s a software model of the very specific business domain you are working in. Often it’s implemented as an object model, where those objects have both data and behavior with literal and accurate business meaning. Creating a unique, carefully crafted domain model at the heart of a core, strategic application or subsystem is essential to practicing DDD. With DDD your domain models will tend to be smallish, very focused. Using DDD, you never try to model the whole business enterprise with a single, large domain model. Phew, that’s good! 上面是引用《实现领域驱动》英文版的一段话，翻译成中文的意思是：领域模型是关于某个特定业务的软件模型，通常通过对象模型来实现，这些对象包含了数据和行为，并且表达了准确的业务含义。 贫血领域对象(Anemic Domain Model) 一个对象缺少行为（业务逻辑），而只有Setter/Getter函数。 对象-关系阻抗失配(Object-Relational Impedance Mismatch) 面向对象向传统关系型数据库存放数据存在表述不一致的问题。 贫血症导致的失忆症 贫血领域对象实现会导致业务意图不明确，最后丢失业务含义，称为失忆了。 Copyright © hsuloong.github.io 2021 all right reserved，powered by Gitbook编辑于： 2021-08-11 17:29:29 "},"domain-driven-design/notes/strategic-modeling.html":{"url":"domain-driven-design/notes/strategic-modeling.html","title":"战略建模","keywords":"","body":"战略建模(Strategic Modeling) 在学习战略建模之前，先理清几个概念： 领域(Domain) 广义上，领域是一个组织所做的事情及其所包含的一切，也就是一个组织的业务范围。比如腾讯的领域是社交，阿里的领域是电子商务。 一个领域在DDD中会划分成多个子域，而领域模型则是在限界上下文中完成开发。 子域(Subdomain) 以《实现领域驱动设计》书中一个图为例： 最大边界是一个领域，内部被划分成多个子域。 核心域(Core Domain) 具有最大业务价值的子域，通常是一个业务核心竞争力。 上图为一个抽象的领域，其中子域和限界上下文是有可能存在相交的。 支撑子域(Supporting Subdomain) 支持业务但却不是核心域，那么就成为支撑子域，如果能够通用于整个业务系统，那么便成为通用子域。 通用子域(Generic Subdomain) 可以应用于整个业务系统，比如身份验证子域可能成为通用子域。 大泥球架构(Ball of Mud) 基本上所有难以维护、打补丁式优化的系统大概率是一个大泥球。这些软件系统杂乱无章、臃肿庞大。 问题空间(problem space) 问题空间是领域的一部分，是核心域和其他子域的组合。 解决方案空间(solution space) 解决方案空间包含一个或者多个限界上下文(一组特定软件模型)，限界上下文可以理解为是一个特定的软件解决方案。 一般而言尽量使得子域和限界上下文一对一对应，或者将多个限界上下文包含在一个子域中。 上图为某个ERP系统的领域划分图。 上下文映射图(Context Maps) 用于完成不同限界上下文的集成以及通用语言的映射。 限界上下文(Bounded Context) A Bounded Context is an explicit boundary within which a domain model exists. Inside the boundary all terms and phrases of the Ubiquitous Language have specific meaning, and the model reflects the Language with exactness. 一个显式的边界，和通用语言一对一，领域模型存在于该边界之内。 限界上下文并不是只包含领域模型，如果领域模型驱动着数据库Schema设计，那么数据库Schema也属于该上下文之中。有如果用户界面驱动着模型行为，该用户界面也属于上下文。 最后《实现领域驱动设计》书中给出了SaasOvation团队战略设计后的结果，如下图： 上下文映射图(Context Map) 当开始采用DDD时，需要先绘制上下文映射图，该图包括所处业务项目的上下文映射图以及集成关系。 图差不多长这个样子： 图中U(Upstream)代表上游，D(Downstream)代表下游。 在进行上下文集成的时候，上下文主要有这些集成关系： 合作关系(Partnership) 两个限界上下文一荣俱荣，一损俱损，这时候会协调开发计划和集成管理，接口演化上同时满足两个系统的需求。 共享内核(Shared Kernel) 共享模型和代码，需要多方协商一致来保证内核状态的稳定。 客户方-供应方(Customer-Supplier) 两个团队处于上下游关系，且上游可以独立于下游完成开发，可能会导致下游团队的开发受到很大的影响。 遵奉者(Conformist) 两个团队也是属于上下游的关系，但是上游没有动力提供下游所需时，下游只能盲目使用上游团队的模型。 防腐层(Anticorruption Layer) 如果合作关系、共享内核、客户方-供应方关系无法顺利实现，会导致两个限界上下文之间的翻译沟通变得困难，此时可以通过防腐层来进行自己方的模型与他方模型的翻译转换。 PS：可使用ACL来缩写。 开放主机服务(Open Host Service) 定义协议，子系统通过协议来访问，比如RPC协议。 PS：可使用OHS来缩写。 发布语言(Published Language) 在两个限界上下文之间的一种公用的翻译语言，通过这个发布语言完成限界上下文之间的集成，一般会和开放主机服务一起使用。 发布语言可以是XML、Protocol Buffers、Json等。 PS：可使用PL来缩写。 另谋他路(Separate Ways) 如果两个限界上下文不存在显著关系，那么就不进行集成。 大泥球(Big Ball of Mud) 已有系统的模型可能是混乱不堪的，其边界非常模糊。此时应该为这个系统划定边界，这里面便是大泥球。此时不要试图通过复杂的建模手段来解决已有系统的问题，而是警惕这个系统会腐蚀其它系统。 下图是《实现领域驱动》书中例子的上下文映射图： 其中身份与访问上下文(Identity and Access Context)、协作上下文(Collaboration Context)是敏捷项目管理上下文(Agile Project Management Context)的上游，他们之间通过开放主机服务+发布语言以及防腐层进行集成。 下面是身份与访问上下文与协作上下文集成的示意图： Copyright © hsuloong.github.io 2021 all right reserved，powered by Gitbook编辑于： 2021-08-11 17:29:29 "},"domain-driven-design/notes/architecture.html":{"url":"domain-driven-design/notes/architecture.html","title":"架构设计","keywords":"","body":"架构(Architecture) DDD实现并不需要特定的架构，因为其可以适用多种风格的架构。在选择具体的架构风格时，需要重点考虑软件质量。同时不要盲目使用架构，只有在能够降低项目失败风险才使用。 目前DDD已知使用比较多的架构主要有： 分层架构 六边形架构 CQRS架构 分层架构(The Layers Architecture) 分层架构在很多地方都有使用，比如后台经典的三层架构：接入层->Ao层->DAO层。 在分层架构中，高层只依赖比自己低的层，也就是每层只能与位于下方的层产生耦合。如下图为一个经典的DDD分层架构： 总共四层： 用户接口层(User Interface Layer) 用于处理用户显示和请求，不应该包含任何的领域或者业务逻辑。应用层是用户接口层的直接使用者。 应用层(Application Layer) 承载应用服务，也不应该出现领域逻辑。在应用层可以用于控制持久化事务和安全认证或者向其他系统发送基于事件的消息通知或者邮件。应用层本身虽然不处理业务逻辑，但是却是领域模型的直接使用者，可以协调领域对象的操作。 应用的行为可以归纳为：接受参数->通过资源库获取聚合实例->执行相应的命令。 要时刻记住，应用层是很薄的一层，如果很复杂，可能意味着领域逻辑泄漏到应用层了，将会导致产生贫血模型。 应用层也可以调用领域服务来完成相关的任务操作，但这些操作必须是无状态的。 领域层(Domain Layer) 基础设施层(Infrastructure Layer) 分层架构按照风格可以进一步分为： 严格分层架构(Strict Layers Architecture) 某层只能与直接位于下方的层发生耦合。 松散分层架构(Relaxed Layers Architecture) 允许某层与任意下方层发生耦合。 在实操中，由于用户接口层和应用层可能需要与基础设施打交道，所以很多都是松散分层架构。 分层架构 + 依赖倒置(DIP) 在实现领域模型的时候，一般会尽量避免与基础设施层发生耦合。为了实现这个，可以使用依赖倒置原则（Dependency Inversion Principle, DIP），DIP原则表述如下： （1）高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。 （2）抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。 这两句话在具体代码实现中可以理解为：1.定义低层的抽象接口；2.低层继承实现该抽象接口；3.高层使用多态技术调用低层的实现。 依赖倒置后分层架构将会变成下图： 依赖倒置后，可以在领域层定义资源库的接口，然后在基础设施层实现，最后可以使用依赖注入技术来注入基础设施的实现。 六边形架构（端口与适配器）(Hexagonal Or Ports and Adapter) 在分层架构使用依赖倒置技术+依赖注入技术以后，高层、低层都只依赖抽象，使得似乎抹平了分层的概念，也就是我们把分层架构推平了，这时候如果加上对称性，就会形成六边形架构了。 下图是六边形架构示意图： 六边形架构中，主要有内部区域和外部区域组成。内部区域用于处理外部区域的请求，外部区域则是提交请求输入。 面向服务架构(Service-Oriented Architecture) 《实现领域驱动设计》一书中列出了一些面向服务架构的原则供参考： 如果将面向服务架构与六边形架构结合起来，将会得到如下架构图： 关于什么是面向服务架构，可以参考Service-oriented architecture和什么是面向服务的架构 REST架构(Representational State Transfer) TODO 命令和查询职责分离CQRS(Command-Query Responsibility Segregation) TODO 事件驱动架构(Event-Driven Architecture) TODO Copyright © hsuloong.github.io 2021 all right reserved，powered by Gitbook编辑于： 2021-08-11 17:29:29 "},"domain-driven-design/notes/tactical-modeling.html":{"url":"domain-driven-design/notes/tactical-modeling.html","title":"战术建模","keywords":"","body":"战术建模(Tactical Modeling) 战术建模是指设计DDD中的组成构造块，比如实体、值对象、聚合、领域服务、领域事件、模块、资源库、应用服务等。 实体(Entity) 在面向对象的开发模式中，一个类会封装对象属性以及相应的操作，这时我们如果需要区分不同的类对象，便会引入一个身份标识，不同身份标识的对象完全是两个东西。 而在领域驱动设计中，我们称能够区分的不同对象为实体。实体在生命周期中可以对内部属性进行任何的修改，但是修改后的实体依然认为是同一个实体。 根据上述描述，实体有两个重要的特点：1. 唯一身份标识(Unique Identity)；2.可变性(Mutability Characteristics)。 有了实体这个概念后，有一个重要的问题就是怎么来创建实体的身份标识。《实现领域驱动设计》一书中给除了几种常用的方法： （1）由户提供初始值唯一值 比如微信注册由用户提供微信号的方式。 这种方式非常直接，但却十分依赖于用户提供的高质量标识，这也是后期导致复杂性的原因之一。 比如后期用户想修改标识或许将是一件十分困难的事情。 （2）程序内部通过某种算法自动生成 比如UUID和GUID。这些可以通过如java.util.UUID库或者Snowflake等唯一ID生成算法。 不过需要注意的是，一般建议用值对象来维护一个唯一标识，因为唯一标识里面可能会有一些额外的细节信息，这些信息可以通过值对象接口暴露给外部。 PS：程序生成唯一标识建议在资源库中实现。 （3）持久化存储机制生成 比如Mysql的自增ID。 在实践中，可以定义一张表专门用于生成自增ID。 （4）由另外一个限界上下文生成 比如内部业务系统会使用某个限界上下文的已经定义好的标识。 举个栗子：用户通过输入手机号后，可以根据这个手机号查找用户唯一标识。 在解决了唯一标识的生成方法后，下面一个需要解决的问题就是何时生成了。一般会有如下时间节点： （1）持久化前 在持久化之前如果你需要唯一标识来完成一些工作（比如对外发布领域事件），那么你必须在持久化前就生成唯一标识。 （2）持久化后 比如完全采用数据库来帮助你生成唯一标识。 最后，唯一标识一旦生成，多数情况下都不应该被修改，也就是需要在整个实体生命周期中保持标识的稳定性。 确保实体唯一的问题解决后，最重要的就是丰富实体的属性和行为了，在战略建模中，整个团队已经开发出了通用语言，其中有动词、名词、形容词。从这些词语之中，我们便能分析出某个限界上下文有哪些实体以及这些实体需要进行哪些行为。 比如有一句：用户可以给自己的好友发送短消息。 从这句话中，我们可以提取出名词：用户、好友、短消息；动词：发送。 根据上面这句话，这里肯定存在一个实体：用户。 然后就是根据通用语言设计实体属性，再接下来就是挖掘实体的关键行为。 比如用户有一个好友列表、有手机号等，这些都是用户属性。 用户可以添加好友，可以删除好友，可以给好友发消息，这些都是用户实体的关键行为。 通过不停的沟通讨论以及随着团队对模型了解的深入，实体的内容也将会越来越丰富。 由于实体一般是通过一些传入参数进行创建，为了保证实体各种属性的有效性，一般需要验证属性值的合法性，或者说验证整个对象的合法性。 验证方法可以在构造函数中验证，如果验证过程非常复杂，那么也可以通过一定义一些辅助验证Handler来辅助校验，甚至可以用一个领域服务来进行验证。 值对象(Value Object) 在上节实体中我们提到了实体两个重要的特点：唯一和可变性。其中唯一含义是就算实体其他属性完全一样，只要唯一标识不一样依然认为是两个不同的实体；可变则意味着实体内部属性可以被修改。 而值对象则刚好相反：不变性和无唯一标识。不变代表值对象不会单独修改对象的某个属性，而是做整体替换；无唯一标识则意味着只要值对象属性全部相等，那么就认为是同一个值对象。 也正是由于值对象的不变性，因此值对象拷贝可以采用浅拷贝的方式。 值对象的这个特点可以简化对值对象的使用。不变意味着我们可以不用担心对值对象的修改，可以认为是一个无害的对象。 《实现领域驱动》一书中对于是否应该建模成值对象给了一些原则： （1）It measures, quantifies, or describes a thing in the domain. （2）It can be maintained as immutable. （3）It models a conceptual whole by composing related attributes as an integral unit. （4）It is completely replaceable when the measurement or description changes. （5）It can be compared with others using Value equality. （6）It supplies its collaborators with Side-Effect-Free Behavior. 一般在实践中，一个值对象表示一个完整的概念，比如地址是一个完整的概念，其由国家、省、市字段组成，这时把地址建模成一个值对象是合理的。 在值对象上面定义的方法都是无副作用函数(Side-Effect-Free Function)，也就是任何方法都不能修改值对象内部的状态，在C++中可以理解为所有函数都是const函数。 除了在自己的限界上下文使用值对象外，在进行上下文集成时，也尽量通过值对象去建模其他上下文的概念，也就是所谓的最小化集成(Integrate with Minimalism)。 聚合(Aggregate) 为什么要使用聚合？聚合是用来组成一致性边界的，所有的操作都是在聚合上实现的，聚合内部再协调实体、值对象完成相应的操作。 聚合设计过大过小都会出现问题。聚合过大可能会导致并发下降，其本身也十分臃肿；聚合过小则可能会导致无法保证领域内对象的状态一致性。 在《实现领域驱动设计》一书中给出了几个设计聚合的原则： （1）Model True Invariants in Consistency Boundaries 在一致性边界之内建模真正的不变条件。不变条件表示一个业务规则始终是一致的(An invariant is a business rule that must always be consistent)。 一致性在这里主要是事务一致性，也就是说在持久化中使用单事务来管理聚合的一致性，即在一个事务中只会修改一个聚合。 （2）Design Small Aggregates 设计小聚合，这个也符合软件世界的复杂问题分解成简单小的问题来解决。正如前面所说，聚合过大可能会导致持久化性能受到影响，也有可能会影响将聚合加载到内存的速度。 （3）Reference Other Aggregates by Identity 通过唯一标识引用其他聚合。不要采用组合的方式直接引用其他聚合，而是采用唯一标识的方式，这样也间接表明我们不会在一个事务中修改多个聚合。 在实践中可以在应用服务中来处理聚合的依赖关系，以避免在聚合中使用资源库或者领域服务。 （4）Use Eventual Consistency Outside the Boundary 在聚合外界之外使用最终一致性。上面写到不要在一个事务中修改多个聚合，那么如果用户命令确实需要多个聚合的情况下，可以通过消息来使得多个聚合最终一致。最终一致会存在一定的延迟，这个需要考虑能否接受这个延迟。 关于使用事务一致或者最终一致，有一个原则可供参考： When examining the use case (or story), ask whether it’s the job of the user executing the use case to make the data consistent. If it is, try to make it transactionally consistent, but only by adhering to the other rules of Aggregates. If it is another user’s job, or the job of the system, allow it to be eventually consistent. 虽然原则是一个很好的参考标准，但是软件开发总有例外，如果要打破上述原则，那么可能需要有一些充足的理由： （1）User Interface Convenience 为了用户方便，也就是用户为本。 （2）Lack of Technical Mechanisms 缺乏技术机制，毕竟巧妇难为无米之炊。 （3）Global Transactions 需要全局事务，在很多金融领域可能会用到。 （4）Query Performance 为了查询性能，妥协与平衡的艺术。 领域服务(Domain Service) 领域服务应当是无状态的，当某个操作不适合放在聚合、实体或者值对象上，这时候可以采用领域服务。和应用服务不同，领域服务是含有业务逻辑的。 一般而言，领域服务并不意味着一定需要远程、重量级的事务操作。 书中给出了一些判断一个操作是否需要用领域服务来承载的思考点： （1）Perform a significant business process （2）Transform a domain object from one composition to another （3）Calculate a Value requiring input from more than one domain object 在具体实践中，不要过度使用领域服务，而是在必要的时候才使用，否则可能导致贫血模型。至于怎么判断是否需要使用领域服务，除了参考上面的准则，也会随着团队对模型的进一步深入理解而发生变化。 在编码过程中，判断某个操作是否适合放在实体或者聚合里面可以借鉴面向对象编程的SOLID原则，如果有可能违背，那么这时候就可以考虑是否应该放在领域服务中了。 领域事件(Domain Event) 领域事件，就是领域专家所关心的发生在领域中的一些事件，比如对于微信注册，领域专家可能关心用户注册成功这一个事件，那么注册成功就可以认为是领域事件。 领域事件产生后，可能是本限界上下文消费，也有可能是被其他限界上下文消费。下图为《实现领域驱动设计》一书中领域事件一个抽象的流转图： 图中领域事件由聚合发布，经过转储最后被远端订阅者消费。 领域事件可以用来简化系统，将一些系列的操作拆分成多个粒度较小的处理单元。 有一些领域事件如果不是由聚合中的命令操作产生的，那么可以把事件建模成一个聚合，同时可以拥有自己的资源库。这种领域事件可以由领域服务产生，然后添加到资源库中后由消息基础设施进行发布。 一般而言，领域事件建模成聚合后需要生成一个唯一的事件标识，实践中这个唯一标识可能是根据属性计算得到的。 对于本地发布以及消费，可以使用观察者模式，同时在应用服务中注册订阅者。 对于远端订阅者，基础设施可能会提供消息中间件，并且通过两段式事务完成领域事件的发布（因为需要保证聚合持久化存储以及消息中间件持久化存储的最终一致），然后由消息中间件推送领域事件给注册的订阅者。 最后关于领域事件要说的就是事件去重。事件去重包含两层含义：1.发布者去重；2.消费者去重。 发布者去重主要是发布者能通过一定的手段方式重复发送消息，比如通过消息的唯一标识来去重；消费者去重一般是指消费者能够做到消费多条一样的消息最后结果是一样的，也就是消费是幂等的。 模块(Modules) 在DDD中，模块可以理解为组织模型代码的方式，也就是各种类是怎么组织保存的。模块可以理解为某些编程语言里面的包或者命名空间。在设计模块名的时候，应该能充分反映领域中的概念，或者说反映通用语言。 下面是《实现领域驱动设计》一书中设计模块的简单原则： 设计模块及其命名需要给予与设计实体、值对象等领域模型同样的重视程度，保持模块的整洁。 如果借用C++中的namespace概念，那么一个模块组织如下（假设公司域名awesome.com）： namespace com { namespace awesome { namespace context_boundary_a { namespace domain { namespace model { // 这里定义实现实体、聚合、值对象、领域事件等领域对象 } namespace service { // 这里定义实现领域服务 } namespace application { // 这里定义实现应用服务 } namespace infrastructure { // 这里定义实现基础设施层比如资源库 } namespace adapter { // 这里定义实现一些端口适配器 } } } } } 如果在战略建模的过程中有一些概念没办法很好的分离到不同的限界上下文中，那么可以先放在一起并通过模块的方式来划分。 资源库(Repository) 资源库对于领域模型来说可以抽象理解为是一个可以安全存放领域对象的区域，也就是聚合可以通过资源库持久化以及从资源库获取聚合。 通常来说，每一种聚合都将拥有一个资源库，也就是一对一的关系。 一般来说，一个资源库会在领域模型层定义相关接口，然后在基础设施层实现这个接口，由于聚合是有唯一标识的，那么资源库接口设计一般是这样的： class SomeAggregateRepository { public: SomeAggregate FindSomeAggregateOfId(SomeAggregateId id); void SaveSomeAggregate(const SomeAggregate &agg); }; 在上面的SaveSomeAggregate函数可以完成数据库数据的创建或者修改。 资源库通过依赖注入的方式注入领域层，这样也比较方便进行单元测试。 集成限界上下文 一个项目会存在多个限界上下文，这个会体现在战略建模中的上下文映射图。而为了完整整个项目，需要集成这些限界上下文。 《实现领域驱动设计》一书中给出了多个集成的方式： （1）Integration Using RESTful Resources 一个上下文通过URI方式提供REST资源，而客户端则可以通过防腐层来访问这些资源，类似下图： 通过防腐层将依赖限界上下文的概念翻译成本地的值对象。 （2）Integration Using Messaging 通过领域事件来集成，该方式可以增强系统自洽性。 进一步了解 Groovy Grails Ruby on Rails Apache Commons Riak MongoDB Qi4j ActiveMQ RabbitMQ Akka NserviceBus MassTransit Life beyond Distributed Transactions: an Apostate's Opinion Copyright © hsuloong.github.io 2021 all right reserved，powered by Gitbook编辑于： 2021-08-11 17:29:29 "}}